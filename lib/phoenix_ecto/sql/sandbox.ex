defmodule Phoenix.Ecto.SQL.Sandbox do
  @moduledoc """
  A plug to allow concurrent, transactional acceptance tests with Ecto.Adapters.SQL.Sandbox.

  ## Example

  This plug should only be used during tests. First, set a flag to
  enable it in `config/test.exs`:

      config :your_app, sql_sandbox: true

  And use the flag to conditionally add the plug to `lib/your_app/endpoint.ex`:

      if Application.get_env(:your_app, :sql_sandbox) do
        plug Phoenix.Ecto.SQL.Sandbox
      end

  It's important that this is at the top of `endpoint.ex`, before any other plugs.


        plug Phoenix.Ecto.SQL.Sandbox,
          checkout: "/sandbox/checkout"
          checkin: "/sandbox/checkin"


  ## Metadata headers

  A special metadata header must be passed by clients to maintain a sandbox
  session. By default, the `"user-agent"` header is used, but this can be
  customized with the `:header` option. For example:

      plug Phoenix.Ecto.SQL.Sandbox, header: "x-custom"

  The metadata may be encoded for a remote client using `encoded_metadata/1`.

  Then, within an acceptance test, checkout a sandboxed connection as before.
  Use `metadata_for/2` helper to get the session metadata to that will allow access
  to the test's connection.
  Here's an example using [Hound](https://hex.pm/packages/hound):

      use Hound.Helpers

      setup do
        :ok = Ecto.Adapters.SQL.Sandbox.checkout(YourApp.Repo)
        metadata = Phoenix.Ecto.SQL.Sandbox.metadata_for(YourApp.Repo, self())
        Hound.start_session(metadata: metadata)
      end
  """

  import Plug.Conn
  alias Plug.Conn
  alias Phoenix.Ecto.SQL.SandboxSupervisor

  @doc """
  Spawns a sandbox process to checkout a connection for a remote client.

  ## Examples

      iex> {:ok, _owner_pid, metdata} = checkout(MyApp.Repo)
  """
  def checkout(repo, opts \\ []) do
    case Supervisor.start_child(SandboxSupervisor, [repo, self(), opts]) do
      {:ok, owner} ->
        metadata = metadata_for(repo, owner)
        {:ok, owner, metadata}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @doc """
  Checks in a sandbox owner process holding a connection for a remote client.

  ## Examples

      iex> {:ok, owner_pid, metdata} = checkout(MyApp.Repo)
      iex> :ok = checkin(owner_pid)
  """
  def checkin(owner) when is_pid(owner) do
    GenServer.call(owner, :checkin)
  end

  def init(opts \\ []) do
    opts
    |> Enum.into(%{
      sandbox: Ecto.Adapters.SQL.Sandbox,
      header: "user-agent",
      checkout: nil,
      checkin: nil
    })
    |> put_checkout_path()
    |> put_checkin_path()
  end
  defp put_checkout_path(%{checkout: nil} = opts), do: opts
  defp put_checkout_path(%{checkout: {path, repo}} = opts) do
    put_in(opts, [:checkout], {split_path(path), repo})
  end
  defp put_checkin_path(%{checkin: nil} = opts), do: opts
  defp put_checkin_path(%{checkin: path} = opts) do
    put_in(opts, [:checkin], split_path(path))
  end
  defp split_path(path), do: Plug.Router.Utils.split(path)

  def call(%Conn{method: "POST", path_info: path} = conn, %{checkout: {path, repo}} = opts) do
    {:ok, _owner, metadata} = checkout(repo, sandbox: opts.sandbox)

    conn
    |> put_resp_content_type("text/plain")
    |> send_resp(200, encode_metadata(metadata))
    |> halt()
  end
  def call(%Conn{method: "DELETE", path_info: path} = conn, %{checkin: path} = opts) do
    case extract_metadata(conn, opts.header) do
      %{owner: owner} ->
        :ok = checkin(owner)

        conn
        |> put_resp_content_type("text/plain")
        |> send_resp(200, "")
        |> halt()

      %{} ->
        conn
        |> send_resp(410, "")
        |> halt()
    end
  end

  def call(conn, %{header: header, sandbox: sandbox}) do
    _result =
      conn
      |> extract_metadata(header)
      |> allow_sandbox_access(sandbox)

    conn
  end

  defp extract_metadata(%Conn{} = conn, header) do
    conn
    |> get_req_header(header)
    |> List.first()
    |> decode_metadata()
  end

  @doc """
  Returns metadata to associate with the session
  to allow the endpoint to acces the database connection checked
  out by the test process.
  """
  @spec metadata_for(Ecto.Repo.t | [Ecto.Repo.t], pid) :: map
  def metadata_for(repo_or_repos, pid) when is_pid(pid) do
    %{repo: repo_or_repos, owner: pid}
  end

  @doc """
  Encodes metadata generated by `metadata_for/2` for client response.
  """
  def encode_metadata(metadata) do
    encoded =
      {:v1, metadata}
      |> :erlang.term_to_binary()
      |> Base.url_encode64()

    "BeamMetadata (#{encoded})"
  end

  @doc """
  Decodes encoded metadata back into map generated from `metadata_for/2`.
  """
  def decode_metadata(encoded_meta) when is_binary(encoded_meta) do
    last_part = encoded_meta |> String.split("/") |> List.last()
    case Regex.run(~r/BeamMetadata \((.*?)\)/, last_part) do
      [_, metadata] -> parse_metadata(metadata)
      _             -> %{}
    end
  end
  def decode_metadata(_), do: %{}

  defp allow_sandbox_access(%{repo: repo, owner: owner}, sandbox) do
    Enum.each(List.wrap(repo), &sandbox.allow(&1, owner, self()))
  end
  defp allow_sandbox_access(_metadata, _sandbox), do: nil

  defp parse_metadata(encoded_metadata) do
    encoded_metadata
    |> Base.url_decode64!()
    |> :erlang.binary_to_term()
    |> case do
         {:v1, metadata} -> metadata
         _               -> %{}
       end
  end
end
